# MySTL
出于练习C++的目的把STL的几个组件简单实现了一遍，包括内存分配器、vector、list以及map和set的底层数据结构红黑树（含金量最高，最耗费心血），并在main文件中写了测试代码。

开发过程中两个花费我较多时间但解决后很有收获的bug，记录一下：

1、测试list的erase(list_iterator<T>  start,  list_iterator<T>  end)函数时，执行erase(it+1, it+7)，it为迭代器，链表出现死循环。

分析：原因是迭代器的加法重载成自加的形式，而C/C++的函数传参是从右到左的，假设it一开始指向list的第一个节点， 运行erase(it+1, it+7)的时候，先传参给end，it进行加7操作，指向第8个节点，即end指向第8个节点，再传参给start，it进行加1操作，由于it已经指向第八个节点，再加1指向第9个节点，即start指向第9个节点，这就导致要删除的区域起点在终点的后面，进而出现死循环。

解决办法：
将迭代器的加法重载由返回自身改为返回一个新的迭代器。


2、写红黑树时new100个节点，依次插入构成一颗红黑树，之后删除值为44的节点再重新插入该节点，结果在插入时程序进入死循环。

分析：一开始以为是红黑树的修正操作代码写错，反复与linux的红黑树源码比较后未发现错误。折腾了三天终于想明白，我的删除操作过程是将44节点的父节点指向44节点的子树指针指向44节点的子树，然后进行修正操作，而此时这个被删除的44节点还保留着它没被删除之前的信息（父节点、左子树、右子树、颜色等），之后我再将这个44节点插入红黑树，如果它被插入成叶子节点，必然引起逻辑错误（它带着之前的信息插入，左右子树不为空）。

解决办法：
1、在代码删除操作后，将删除节点的左右子树、父子树置为空，颜色置为红色（原方案）；
2、每次向红黑树添加节点，在堆上建立一个新节点与用户传进来的节点一样，红黑树使用堆上的这个节点，每次删除之后把该节点delete掉，该做法还有一个好处是可以向全局红黑树插入局部节点，因为红黑树会在堆上将该节点拷贝一份，实际使用堆上的节点（现方案）。
